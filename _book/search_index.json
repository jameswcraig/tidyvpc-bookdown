[
["index.html", "Introduction to tidyvpc Chapter 1 Installation 1.1 CRAN 1.2 Development version from GitHub", " Introduction to tidyvpc James Craig 2020-04-07 Chapter 1 Installation 1.1 CRAN install.packages(&quot;tidyvpc&quot;) 1.2 Development version from GitHub Install devtools if not previously installed. install.packages(&quot;devtools&quot;) If there are errors (converted from warning) during installation related to packages built under different version of R, they can be ignored by setting the environment variable R_REMOTES_NO_ERRORS_FROM_WARNINGS=\"true\" before calling install_github() Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS=&quot;true&quot;) devtools::install_github(&quot;jameswcraig/tidyvpc&quot;) "],
["intro.html", "Chapter 2 Introduction 2.1 Data", " Chapter 2 Introduction When deriving a Visual Predictive check (VPC) you must: Have both observed and simulated datasets that include x &amp; y variables, typically TIME &amp; DV. Compute Prediction Intervals on Simulated versus Observed Data When deriving a VPC you may want to: Stratify over variables in your model. Censor data below LLOQ. Perform prediction correction (pcVPC). The tidyvpc package makes these steps fast and easy: By providing readable syntax using the %&gt;% operator from magrittr. It uses efficient backend computation, taking advantage of data.table parallelization. By providing traditional binning methods and new binless methods using additive quantile regression and loess for pcVPC. By using ggplot2 graphics engine to visualize the results of the VPC. This document introduces you to tidyvpc’s set of tools, and shows you how to apply them to tidyvpcobj to derive VPC. All of the tidyvpc functions take a tidyvpcobj as the first argument, with the exception of the first function observed() in the piping chain, which takes a data.frame or data.table of the observed dataset. Rather than forcing the user to either save intermediate objects or nest functions, tidyvpc provides the %&gt;% operator from magrittr. The result from one step is then “piped” into the next step, with the final function in the piping chain always vpcstats(). You can use the pipe to rewrite multiple operations that you can read left-to-right, top-to-bottom (reading the pipe operator as “then”). 2.1 Data To explore the functionality of tidyvpc, we’ll use an altered version of obs_data(vpc::simple_data$obs) &amp; sim_data(vpc::simple_data$sim) from the vpc package. These datasets contains all necessary variables to explore the functionality of tidyvpc including: DV (y variable) TIME (x variable) NTIME (nominal time for binning on x-variable) GENDER (gender variable for stratification, “M”, “F”) STUDY (study for stratification, “Study A”, “Study B”) PRED (prediction variable for pcVPC) MDV (Missing DV) library(tidyvpc) obs_data &lt;- tidyvpc::obs_data sim_data &lt;- tidyvpc::sim_data head(obs_data) ## ID TIME DV AMT DOSE MDV NTIME GENDER STUDY ## 1 1 0.0000000 0.0 150 150 1 0.00 M Study A ## 2 1 0.2157624 37.3 0 150 0 0.25 M Study A ## 3 1 0.4694366 62.2 0 150 0 0.50 M Study A ## 4 1 0.8271844 74.1 0 150 0 1.00 M Study A ## 5 1 1.7724895 75.1 0 150 0 1.50 M Study A ## 6 1 1.7142415 58.3 0 150 0 2.00 M Study A 2.1.1 Preprocessing data First we’ll need to subset our data by filtering MDV == 0 which removes rows where both DV == 0 &amp; TIME == 0. obs_data &lt;- as.data.table(obs_data) sim_data &lt;- as.data.table(sim_data) obs_data &lt;- obs_data[obs_data$MDV == 0,] sim_data &lt;- sim_data[sim_data$MDV == 0,] Next we’ll add the prediction variable from the first replicate of simulated data into our observed data. obs_data$PRED &lt;- sim_data$PRED[sim_data$REP == 1] Now that we have our data ready to derive VPC, proceed to the next chapter to learn about using the various functions in the tidyvpc package. "],
["functions.html", "Chapter 3 Functions 3.1 observed() 3.2 simulated() 3.3 binning() 3.4 binless() 3.5 vpcstats() 3.6 stratify() 3.7 censoring() 3.8 predcorrect()", " Chapter 3 Functions 3.1 observed() The observed() function is always the first function used in the VPC piping chain and is used to specify the observed dataset and corresponding variables. There are three arguments that are required in order to use observed. The first argument is either a data.frame or data.table, the second argument is the name of x-variable in the observed data, and the third argument is the name of the y-variable. Note variable names should be unquoted. vpc &lt;- observed(obs_data, x = TIME, y = DV) 3.2 simulated() The simulated() function is used to specify the simulated dataset and corresponding variables. There are two arguments that are required in order to use simulated(). Since the function is “piped” in after the observed() function, the first argument is the tidyvpcobj and should not be included, followed by the name of the simulated data, then the name of y-variable in the simulated data. Variable names should be unquoted and x-variable should not be included as it is recycled from the observed() function. vpc &lt;- observed(obs_data, x = TIME, y = DV) %&gt;% simulated(sim_data, y = DV) 3.3 binning() The binning() function provides the binning method to derive the vpc and should be inputted as a character string in the bin argument. Binning methods include: “ntile”, “pam”, “sd”, “equal”, “pretty”, “quantile”, “kmeans”, “jenks”, “centers”, “breaks”. Some methods such as “ntile” and “pam” will require you to specify the number of bins using the nbins argument i.e. nbins = 9. If using bin = \"centers\" or bin = \"breaks you must also provide the centers/breaks argument as numeric vector in the function i.e. centers = c(1,3,5,7). You can also bin directly on x-variable. If using this type of binning, the bin argument should be the unquoted variable name that you used in the observed() function i.e. bin = NTIME for the Nominal Time variable in the data. Binning on x-variable, NTIME vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binning(bin = NTIME) Binning with “ntile” vpc &lt;- observed(obs_data, x = TIME, y = DV) %&gt;% simulated(sim_data, y = DV) %&gt;% binning(bin = &quot;ntile&quot;, nbins = 9) Binning with “breaks” vpc &lt;- observed(obs_data, x = TIME, y = DV) %&gt;% simulated(sim_data, y = DV) %&gt;% binning(bin = &quot;breaks&quot;, breaks = c(1,5,7,9,10)) 3.4 binless() Binless methods utilize additive quantile regression (AQR) in place of traditional binning. Use the binless() function instead of binning() to derive a binless VPC. By default, binless() performs AQR at the 5%, 50%, and 95% quantiles but you can change this using the qpred argument which takes a numeric vector of length 3 i.e. qpred = c(.1, .5, .9) for the 10%, 50%, 90% quantiles. The lambda smoothing parameters for each quantile are optimized by default with AIC as indicated by the optimize = TRUE argument, however, if you would like to use different lambda values for each quantile set optimize = FALSE and specify lambda values for each quantile as a numeric vector of length 3 with the lambda argument i.e. lambda = c(1,3,2) corresponds to the lambda values for the quantiles in the qpred argument (lower, median, upper). Note: the higher the lambda value the smoother fit to the data. Binless optimized vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binless() Binless with user specified lambda values at 10%, 50%, 90% quantiles. Set optimize = FALSE and provide lambda smoothing parameters as a vector of length 3 for lower, median, upper quantiles. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binless(qpred = c(0.1, 0.5, 0.9), optimize = FALSE, lambda = c(1,3,2)) 3.5 vpcstats() The vpcstats() function is always the final function used in the piping chain and calculates the statistics needed to plot a VPC. If using binning()methods, you may specify alternative quantiles using the qpred argument. The default quantiles used are 5%, 50%, 95% i.e. qpred = c(0.05, 0.5, 0.95). If using binless() method, there is no need to include the qpred() argument here as the quantile values supplied in the binless() function will be used to calculate the VPC statistics for plotting. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binning(bin = NTIME) %&gt;% vpcstats() plot(vpc) 3.6 stratify() To stratify VPC include the stratify() function before using the binning() or binless() function and use the unquoted stratification variable(s) name as a formula. Let’s stratify on GENDER in the data, which contains 2 levels (GENDER = “M”, GENDER = “F”). Include as many stratification variables as your model calls for. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% stratify(~ GENDER) %&gt;% binning(bin = &quot;pam&quot;, nbins = 7) %&gt;% vpcstats() plot(vpc) Using multiple stratification variables GENDER and STUDY. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% stratify(~ GENDER + STUDY) %&gt;% binless() %&gt;% vpcstats() plot(vpc) 3.7 censoring() To censor observed data below lower limit of quantification (LLOQ), include the censoring() function after simulated() and use the lloq argument to specify either a variable in the data or specific value for censoring. The blq argument creates a logical TRUE/FALSE in the data that indicates whether the value is below the limit of quantification and is typically defined as rows with DV &lt; LLOQ in the data. Using the censoring() function will censor only observed data below lower limit of quantification when plotting, simulated data will still be plotted. Censoring using numeric value. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% censoring(blq=(DV &lt; 25), lloq=25) %&gt;% binning(bin = &quot;jenks&quot;, nbins = 5) %&gt;% vpcstats() plot(vpc) Censoring using LLOQ variable in the data. First, let’s add an LLOQ variable to the observed data. obs_data$LLOQ &lt;- 50 Then we’ll specify lower limit of quantification as the unquoted variable name in our data LLOQ. Let’s also provide our own lambda values. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% censoring(blq=(DV &lt; LLOQ), lloq=LLOQ) %&gt;% binless(optimize = FALSE, lambda = c(1.5, 2.5, 1.7)) %&gt;% vpcstats() plot(vpc) The tidyvpc package also allows you to use different LLOQ for each level of stratification variable. We’ll set an LLOQ value of 50 for Study A and 25 for Study B and calculate statistics at 5%, 50%, 90% quantiles. obs_data$LLOQ &lt;- ifelse(obs_data$STUDY == &quot;Study A&quot;, 50, 25) vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% censoring(blq=(DV &lt; LLOQ), lloq=LLOQ) %&gt;% stratify(~ STUDY) %&gt;% binning(bin = &quot;pam&quot;, nbins = 4) %&gt;% vpcstats(qpred = c(0.1, 0.5, 0.9)) plot(vpc) 3.8 predcorrect() To derive a prediction corrected VPC (pcVPC) use the predcorrect() function. The predcorrect() function takes one required argument pred which should be the unquoted variable name of the population prediction variable in the data. If using binning methods, the predcorrect() function should be called after binning(), however, if performing LOESS pcVPC for binless() methods, use predcorrect() before calling binless() and set binless(loess.ypc = TRUE). Note: if model was fit using log scale of DV make sure to include the argument log = TRUE in predcorrect() to perform the appropriate prediction correction calculation. Prediction corrected using binning methods. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% stratify(~GENDER) %&gt;% binning(bin = NTIME) %&gt;% predcorrect(pred=PRED) %&gt;% vpcstats() plot(vpc) LOESS prediction corrected using binless method for 10%, 50%, 90% quantiles. If optimize = TRUE, the LOESS smoothing parameter, span, will be automatically optimize using AIC. Note: predcorrect() must be called before binless() if setting loess.ypc = TRUE. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% stratify(~GENDER) %&gt;% predcorrect(pred=PRED) %&gt;% binless(qpred = c(0.1, 0.5, 0.9), optimize = TRUE, loess.ypc = TRUE) %&gt;% vpcstats() plot(vpc) To specify your own span value LOESS pcVPC instead of optimizing with AIC, use the span argument in the binless function. Span should be a numeric between [0,1], with higher values providing a smoother fit. Remember, to also include the smoothing parameters for AQR by using the lambda argument and set optimize = FALSE. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% predcorrect(pred=PRED) %&gt;% binless(optimize = FALSE, lambda = c(.95,3,1.2), loess.ypc = TRUE, span = .6) %&gt;% vpcstats() plot(vpc) "],
["advanced.html", "Chapter 4 Advanced 4.1 Binning by Strata 4.2 Binless by Strata 4.3 Visualize Bins 4.4 Bin Information", " Chapter 4 Advanced The following chapter provides advanced use cases of the tidyvpc package. 4.1 Binning by Strata To use different binning methods for different stratification variables, and/or for each level of stratification variable, use multiple calls to the binning() function in combination with the stratum argument. Make sure to set by.strata = T vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% stratify(~ GENDER + STUDY) %&gt;% binning(stratum = list(GENDER = &quot;M&quot;, STUDY = &quot;Study A&quot;), bin = &quot;jenks&quot;, nbins = 5, by.strata = T) %&gt;% binning(stratum = list(GENDER = &quot;F&quot;, STUDY = &quot;Study A&quot;), bin = &quot;centers&quot;, centers = c(0.5,3,5,10,15), by.strata = T) %&gt;% binning(stratum = list(GENDER = &quot;M&quot;, STUDY = &quot;Study B&quot;), bin = &quot;kmeans&quot;, by.strata = T) %&gt;% binning(stratum = list(GENDER = &quot;F&quot;, STUDY = &quot;Study B&quot;), bin = &quot;pam&quot;, nbins = 5, by.strata = T) %&gt;% predcorrect(pred=PRED) %&gt;% vpcstats() plot(vpc) 4.2 Binless by Strata To use different smoothing parameters for each level of stratification variable if using the binless() function use a single call of the binless() function and include a data.frame with the column names of stratification variable and corresponding level. To use different span values for each level of stratification variable use a vector the length of n levels of strata. Note: If using more than one stratification variable with the binless() function you must set optimize = TRUE and optimize lambda and span using AIC. new_lambda = data.frame(GENDER_F = c(2,4,2), GENDER_M = c(1.9,3,2.25) ) vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% stratify(~ GENDER) %&gt;% predcorrect(pred=PRED) %&gt;% binless(qpred = c(0.1, 0.5, 0.9), optimize = FALSE, lambda = new_lambda, loess.ypc = TRUE, span = c(.6, .85)) %&gt;% vpcstats() plot(vpc) 4.3 Visualize Bins If using binning() methods, you can visualize bins by using the plot() function on the tidyvpcobj without calling vpcstats(). Once you are satisifed with the binning method, simply call vpcstats() on the existing tidyvpcobj to compute VPC percentiles and prediction intervals i.e vpc %&gt;% vpcstats() vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binning(bin = &quot;jenks&quot;, nbins = 7) plot(vpc) 4.4 Bin Information To obtain information about the bins, including the number of observations, xmedian, xmean, xmin, xmax, xmidpoint, xleft, xright, and xcenter, use the bininfo() function from tidyvpc. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binning(bin = &quot;jenks&quot;, nbins = 4) %&gt;% vpcstats() bin_information &lt;- bininfo(vpc) head(bin_information) ## bin nobs xmedian xmean xmin xmax xmid ## 1: [0.158,1.89) 213 0.8418133 0.8717959 0.1575342 1.860852 1.009193 ## 2: [1.89,4.83) 187 2.8021930 2.9458444 1.8851078 4.772347 3.328727 ## 3: [4.83,9.45) 96 6.6279698 6.9869973 4.8283449 9.259398 7.043872 ## 4: [9.45,15.8] 54 11.9639045 12.0388598 9.4470340 15.848161 12.647597 ## xleft xright xcenter ## 1: 0.1575342 1.872980 1.015257 ## 2: 1.8729798 4.800346 3.336663 ## 3: 4.8003458 9.353216 7.076781 ## 4: 9.3532162 15.848161 12.600688 "],
["ggplot2.html", "Chapter 5 Extending Further with ggplot2 5.1 Plot VPC 5.2 Plot Rectangles 5.3 Plot Below Quantification Limit (BQL)", " Chapter 5 Extending Further with ggplot2 While the built in plot() function make it easy to quickly visualize the derived VPC, the tidyvpcobj can be plotted using ggplot2 for complete plot customization. 5.1 Plot VPC obs_data$LLOQ &lt;- ifelse(obs_data$STUDY == &quot;Study A&quot;, 50, 25) vpc &lt;- observed(obs_data, x = TIME, y = DV) %&gt;% simulated(sim_data, y = DV) %&gt;% censoring(blq = DV &lt; LLOQ, lloq = LLOQ) %&gt;% stratify(~STUDY) %&gt;% binning(bin = NTIME) %&gt;% vpcstats(qpred = c(0.1, 0.5, 0.9)) ggplot(vpc$stats, aes(x = xbin)) + facet_grid(~STUDY, scales = &quot;free&quot;, as.table = FALSE) + geom_ribbon(aes(ymin = lo, ymax = hi, fill = qname, col = qname, group = qname),alpha = 0.1, col = NA) + geom_line(aes(y = md, col = qname, group = qname)) + geom_line(aes(y = y, linetype = qname), size = 1) + geom_hline(data=unique(obs_data[, .(STUDY, LLOQ)]), aes(yintercept=LLOQ), linetype=&quot;dotted&quot;, size=1) + geom_text(data = unique(vpc$data[, .(LLOQ), by = &quot;STUDY&quot;]), aes(x = 10, y = LLOQ, label = paste(&quot;LLOQ&quot;, LLOQ, sep = &quot;=&quot;), ), vjust = 1, hjust = 1) + scale_colour_manual(name = &quot;Simulated Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.1&quot;, &quot;q0.5&quot;, &quot;q0.9&quot;), values = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;), labels = c(&quot;10%&quot;, &quot;50%&quot;, &quot;90%&quot;)) + scale_fill_manual(name = &quot;Simulated Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.1&quot;, &quot;q0.5&quot;, &quot;q0.9&quot;), values = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;), labels = c(&quot;10%&quot;, &quot;50%&quot;, &quot;90%&quot;)) + scale_linetype_manual(name = &quot;Observed Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.1&quot;, &quot;q0.5&quot;, &quot;q0.9&quot;), values = c(&quot;dotted&quot;, &quot;solid&quot;, &quot;dashed&quot;), labels = c(&quot;10%&quot;, &quot;50%&quot;, &quot;90%&quot;)) + guides(fill = guide_legend(order = 2), colour = guide_legend(order = 2), linetype = guide_legend(order = 1)) + theme(legend.position = &quot;top&quot;, legend.key.width = grid::unit(1, &quot;cm&quot;)) + labs(x = &quot;TIME&quot;, y = &quot;Concentration&quot;) + geom_point(data = vpc$obs, aes(x = x, y = y), size = 1, alpha = 0.1, show.legend = FALSE) + geom_vline(data = bininfo(vpc)[, .(x = sort(unique(c(xleft, xright)))), by = names(vpc$strat)],aes(xintercept = x), size = rel(0.5), col = &quot;gray80&quot;) + theme(panel.grid = element_blank()) + geom_rug(data = bininfo(vpc)[, .(x = sort(unique(c(xleft, xright)))), by = names(vpc$strat)],aes(x = x), sides = &quot;t&quot;, size = 1) 5.2 Plot Rectangles The results from bininfo() make it easy to plot a rectangle VPC using ggplot2. vpc &lt;- observed(obs_data, x=TIME, y=DV) %&gt;% simulated(sim_data, y=DV) %&gt;% binning(bin = &quot;jenks&quot;, nbins = 4) %&gt;% vpcstats() #Get vpcstats df stats &lt;- vpc$stats #Get bininfo df bin_information &lt;- bininfo(vpc) #Left join bin_info to vpcstats on bin bin_information &lt;- stats[bin_information, on = &quot;bin&quot;] #Generate ymin bin_information &lt;- bin_information[, ymin := min(y), by = &quot;bin&quot;] #Generate ymax bin_information &lt;- bin_information[, ymax := max(y), by = &quot;bin&quot;] head(bin_information) ## bin xbin qname y lo md hi nobs ## 1: [0.158,1.89) 0.8418133 q0.05 22.94 19.05306 22.1295 26.32546 213 ## 2: [0.158,1.89) 0.8418133 q0.5 61.50 56.61835 61.7225 68.59207 213 ## 3: [0.158,1.89) 0.8418133 q0.95 144.40 108.56340 132.0360 156.84105 213 ## 4: [1.89,4.83) 2.8021930 q0.05 29.38 23.01417 28.2300 32.95001 187 ## 5: [1.89,4.83) 2.8021930 q0.5 74.10 66.70315 75.9475 82.94110 187 ## 6: [1.89,4.83) 2.8021930 q0.95 179.00 135.74530 155.3395 180.72525 187 ## xmedian xmean xmin xmax xmid xleft xright xcenter ## 1: 0.8418133 0.8717959 0.1575342 1.860852 1.009193 0.1575342 1.872980 1.015257 ## 2: 0.8418133 0.8717959 0.1575342 1.860852 1.009193 0.1575342 1.872980 1.015257 ## 3: 0.8418133 0.8717959 0.1575342 1.860852 1.009193 0.1575342 1.872980 1.015257 ## 4: 2.8021930 2.9458444 1.8851078 4.772347 3.328727 1.8729798 4.800346 3.336663 ## 5: 2.8021930 2.9458444 1.8851078 4.772347 3.328727 1.8729798 4.800346 3.336663 ## 6: 2.8021930 2.9458444 1.8851078 4.772347 3.328727 1.8729798 4.800346 3.336663 ## ymin ymax ## 1: 22.94 144.4 ## 2: 22.94 144.4 ## 3: 22.94 144.4 ## 4: 29.38 179.0 ## 5: 29.38 179.0 ## 6: 29.38 179.0 Plot rectangles using ymin and ymax, the min/max y values in vpc$stats grouped by bin. ggplot(bin_information, aes(x = xbin)) + geom_line(aes(y = md, col = qname, group = qname)) + geom_line(aes(y = y, linetype = qname), size = 1) + geom_rect(aes(xmin= xleft,xmax= xright, ymin = ymin, ymax = ymax),alpha = .1, col = &quot;black&quot;, fill = &quot;green&quot;) + geom_point(data = vpc$obs, aes(x = x, y = y), size = 1, alpha = 0.1, show.legend = FALSE) + scale_colour_manual(name = &quot;Simulated Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.05&quot;, &quot;q0.5&quot;, &quot;q0.95&quot;), values = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;), labels = c(&quot;5%&quot;, &quot;50%&quot;, &quot;95%&quot;)) + scale_linetype_manual(name = &quot;Observed Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.05&quot;, &quot;q0.5&quot;, &quot;q0.95&quot;), values = c(&quot;dotted&quot;, &quot;solid&quot;, &quot;dashed&quot;), labels = c(&quot;5%&quot;, &quot;50%&quot;, &quot;95%&quot;)) + geom_vline(data = bin_information[, list(x = sort(unique(c(xleft, xright))))],aes(xintercept = x), size = rel(0.5), col = &quot;gray80&quot;) + geom_rug(data = bin_information[, list(x = sort(unique(c(xleft, xright))))],aes(x = x), sides = &quot;t&quot;, size = 1) + guides(fill = guide_legend(order = 2), colour = guide_legend(order = 2), linetype = guide_legend(order = 1)) + theme(legend.position = &quot;top&quot;, legend.key.width = grid::unit(1, &quot;cm&quot;)) + labs(x = &quot;TIME&quot;, y = &quot;Concentration&quot;) Alternatively, we can obtain the required data for plotting used in the above bin_information data frame by merging vpc$stats and bininfo(vpc) on bin in the ggplot2 data argument. If stratifying you will need to include the name of the stratification variable(s) in the data.table merge i.e. vpc$stats[bininfo(vpc), on=c(\"STUDY\", \"bin\")]. In the rectangle vpc below, we will stratify on STUDY and plot rectangles for each quantile. obs_data$LLOQ &lt;- obs_data[, ifelse(STUDY == &quot;Study A&quot;, 50, 25)] vpc &lt;- observed(obs_data, x = TIME, y = DV) %&gt;% simulated(sim_data, y = DV) %&gt;% censoring(blq = DV &lt; LLOQ, lloq = LLOQ) %&gt;% stratify(~STUDY) %&gt;% binning(bin = NTIME) %&gt;% vpcstats(qpred = c(0.1, 0.5, 0.9)) ggplot(vpc$stats[bininfo(vpc), on=c(&quot;STUDY&quot;, &quot;bin&quot;)], aes(x = xbin)) + facet_grid(~STUDY, scales = &quot;free&quot;, as.table = FALSE) + geom_rect(aes(xmin = xleft, xmax = xright, ymin = lo, ymax = hi, fill = qname, col = qname, group = qname),alpha = 0.1, col = NA) + geom_segment(aes(x = xleft, xend = xright, y = md, yend = md, col = qname, group = qname)) + geom_segment(aes(x = xleft, xend = xright, y = y, yend = y, linetype = qname), size = 1) + geom_line(aes(y = md, col = qname, group = qname)) + geom_line(aes(y = y, linetype = qname), size = 1) + geom_hline(data=unique(obs_data[, list(STUDY, LLOQ)]), aes(yintercept=LLOQ), linetype=&quot;dotted&quot;, size=1) + geom_text(data = unique(vpc$data[, list(LLOQ), by = &quot;STUDY&quot;]), aes(x = 10, y = LLOQ, label = paste(&quot;LLOQ&quot;, LLOQ, sep = &quot;=&quot;), ), vjust = 1, hjust = 1) + scale_colour_manual(name = &quot;Simulated Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.1&quot;, &quot;q0.5&quot;, &quot;q0.9&quot;), values = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;), labels = c(&quot;10%&quot;, &quot;50%&quot;, &quot;90%&quot;)) + scale_fill_manual(name = &quot;Simulated Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.1&quot;, &quot;q0.5&quot;, &quot;q0.9&quot;), values = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;), labels = c(&quot;10%&quot;, &quot;50%&quot;, &quot;90%&quot;)) + scale_linetype_manual(name = &quot;Observed Percentiles\\nMedian (lines) 95% CI (areas)&quot;, breaks = c(&quot;q0.1&quot;, &quot;q0.5&quot;, &quot;q0.9&quot;), values = c(&quot;dotted&quot;, &quot;solid&quot;, &quot;dashed&quot;), labels = c(&quot;10%&quot;, &quot;50%&quot;, &quot;90%&quot;)) + guides(fill = guide_legend(order = 2), colour = guide_legend(order = 2), linetype = guide_legend(order = 1)) + theme(legend.position = &quot;top&quot;, legend.key.width = grid::unit(1, &quot;cm&quot;)) + labs(x = &quot;TIME&quot;, y = &quot;Concentration&quot;) + geom_point(data = vpc$obs, aes(x = x, y = y), size = 1, alpha = 0.1, show.legend = FALSE) + geom_vline(data = bininfo(vpc)[, list(x = sort(unique(c(xleft, xright)))), by = names(vpc$strat)],aes(xintercept = x), size = rel(0.5), col = &quot;gray80&quot;) + theme(panel.grid = element_blank()) + geom_rug(data = bininfo(vpc)[, list(x = sort(unique(c(xleft, xright)))), by = names(vpc$strat)],aes(x = x), sides = &quot;t&quot;, size = 1) 5.3 Plot Below Quantification Limit (BQL) If using the censoring() function, the resulting tidyvpcobj will also contain a pctblq table. Use ggplot2 to plot the percentage of data below the limit of quantification across bins. We can include geom_ribbon() using the lo and hi columns in the vpc$pctblq table to denote the lower/upper bounds of our confidence interval. Let’s also plot the median %blq of the simulated data using the md column in the vpc$pctblq table. obs_data$LLOQ &lt;- ifelse(obs_data$STUDY == &quot;Study A&quot;, 50, 25) vpc &lt;- observed(obs_data, x = TIME, y = DV) %&gt;% simulated(sim_data, y = DV) %&gt;% censoring(blq = DV &lt; LLOQ, lloq = LLOQ) %&gt;% stratify(~STUDY) %&gt;% binning(bin = NTIME) %&gt;% vpcstats(qpred = c(0.1, 0.5, 0.9)) ggplot(vpc$pctblq) + facet_grid(~STUDY) + geom_ribbon(aes(x = xbin, ymin= lo, ymax = hi), fill = &quot;red&quot;, alpha = .2) + geom_line(aes(x = xbin, y = y)) + geom_line(aes(x = xbin, y = md), color = &quot;red&quot;) + labs(x= &quot;TIME&quot;, y= &quot;% BLQ&quot;) "]
]
